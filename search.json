[{"title":"React如何设计一个流程","url":"/2017/12/26/webfront/React如何设计一个流程/","content":"\n流程在前端应用（App）上的使用是非常广的，比如注册、申请功能、下单购买、开票、使用引导等。React 组件实际上是一个状态机，所以，我们可以基于这个特点来设计一个简单的流程。\n\n<!--more-->\n\n假设我们现在要设计一个申请服务的流程。\n\n#### 结构\n\n我们先来看一下结构图。其中包含几个界面之间的流转逻辑。\n\n![](流程组件设计.png)\n\n一个流程中按用途来分可以包含两种组件，**容器组件**和** UI 组件**。\n\n#### 实现\n\n##### **容器组件**\n\n控制流程流转的流程组件我们称之为**容器组件**（Container），在实际界面中没有显式的存在，主要作用是控制流程的状态和流程的流转，传递数据流等。\n\n###### **状态**\n\n在容器组件中，设置一个 state 作为状态机的状态，step。step 的初始状态为0。\n\n```js\nclass Flow extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            step: 0,\n        };\n    }\n    ...\n}\n\nexport default Flow;\n```\n\n###### **渲染函数**\n\n每一个状态对应一个UI组件的渲染函数。\n\n```js\n    ...\nflow() {\n    const {step} = this.state;\n    switch (step) {\n        case 0:\n            return this.renderLoading();\n        default:\n        case 1:\n            return this.renderApply();\n        case 2:\n            return this.renderConfirmInfo();\n        case 3:\n            return this.renderUnderReview();\n        case 4:\n            return this.renderContent();\n        case 5:\n            return this.renderAgreement();\n    }\n}\n\nrender() {\n    return <div>{this.flow()}</div>;\n}\n    ...\n```\n\n渲染函数主要是渲染一个UI 组件，包括数据流的传递，回调改变状态等，先不关心数据的来源：\n\n```js\n...\nrenderConfirmInfo() {\n    const {login, profile, isFetching} = this.props;\n    return (\n        <ConfirmInfo\n            login={login}\n            profile={profile}\n            loading={isFetching}\n            next={this.toUnderReview}\n            back={this.toApply}\n        />\n    );\n}\n\nrenderLoading() {\n    return <Loading/>;\n}\n...\n```\n\n###### 流转控制\n\n接下来是流转控制，在上面的代码中可以注意到 UI 组件有个两个属性叫 next 和 back，这两个属性可以传递控制函数控制流程的运转。\n\n```js\n...\ntoAgreement() {\n    this.setState({step: 5});\n}\n\ntoConfirmInfo() {\n    this.setState({step: 2});\n}\n...\n```\n\n到这里基本就完成一个流程组件的主要设计。\n\n##### UI 组件\n\n第二类组件是 **UI 组件**，主要为展示各部分具体功能的组件，会在界面上显示存在。UI 组件的设计就和平时的组件设计没有什么差别了，只是要在原有功能的基础上，添加 next 和 back 两个属性，并在合适的时机去调用这两个函数并回传一些必要的数据。下面是其中一个组件的大致结构：\n\n```js\nfunction Agreement({next, back}) {\n    return (\n        <div>\n            <div className=\"agreement-body\">\n                ...\n            </div>\n            <div className=\"agreement-footer\">\n                <Button onClick={next}>接受</Button>\n                <Button onClick={back}>\b返回</Button>\n            </div>\n        </div>\n    );\n}\n\nAgreement.propTypes = {\n    next: PropTypes.func,\n    back: PropTypes.func,\n};\n\nexport default Agreement;\n```\n\n##### 数据接入\n\n上面主要谈到界面上的设计，而没有关心数据的接入问题。实现了容器组件，基本上可以对容器组件的作用有一个比较清楚的认识，数据也应当对接到容器组件中去。基于这样的观点，我们可以接入很多的数据来源，比如，Redux 或者直接去发起 AJAX 请求。\n\n###### Redux\n\n将 Flow 组件连接到 store 中，并在生命周期 componentWillReceiveProps 中实现相关逻辑就可以了。前面的例子可以继续完善：\n\n```js\n// import\n\nclass Flow extends React.Component {\n\n    constructor(props) {\n        super(props);\n        this.state = {\n            step: 0,\n        };\n    }\n\n    componentWillMount() {\n        const {getStatus} = this.props;\n        if (isFunction(getStatus)) {\n            getStatus();\n        }\n    }\n\n    componentWillReceiveProps(nextProps) {\n        const {status} = nextProps;\n        const {step} = this.state;\n\n        // 初始化的时候根据 store 中某个变量来设置 step\n        if (step === 0) {\n            if (status === -1) {\n                this.setState({step: 1});\n            } else if (status === 0) {\n                this.setState({step: 3});\n            } else if (status === 1) {\n                this.setState({step: 4});\n            }\n        }\n    }\n        ...\n}\n\n// Flow.propTypes\n\nexport default connect(state => ({\n    login: state.login,\n    profile: state.profile,\n    ...\n}), dispatch => ({\n    actions: bindActionCreators(Actions, dispatch)\n}))(Flow);\n```\n\n###### AJAX 请求\n\n如果没有使用其他第三方数据流管理库，也可以直接发起请求：\n\n```js\n// import\n\nclass Flow extends React.Component {\n\n    constructor(props) {\n        super(props);\n        this.state = {\n            step: 0,\n        };\n    }\n\n    componentWillMount() {\n        const {getStatus} = this.props;\n        fetch('/xxx').then((res) => {\n            const {status} = res;\n            if (status === -1) {\n                this.setState({step: 1});\n            } else if (status === 0) {\n                this.setState({step: 3});\n            } else if (status === 1) {\n                this.setState({step: 4});\n            }\n        })\n    }\n\n    ...\n}\n\n// Flow.propTypes\n\nexport default Flow;\n```\n\n简单流程的设计到这里就基本结束了。\n\n当然，这个东西使用 react-router 导航来做也是可以实现的，我只是提供这样的一种思路作为参考，孰优孰劣还请大家来判断。\n","tags":["流程"],"categories":["web前端"]},{"title":"基于Token的身份验证","url":"/2017/12/24/web/基于Token的身份验证/","content":"\n简单介绍 Cookie-Session，XSS，CSRF 相关基础，和基于 Token 的身份验证过程。\n<!--more-->\n\nHTTP 协议是一种无状态的协议。这意味着本次请求使用用户名密码通过验证之后，下次请求服务器还是不知道是谁发送的请求，还需要再次验证。\n\n#### Cookie-Session 身份验证\n\n最常用的解决方法就是，当用户请求登录的时候，如果没有问题，我们在服务端生成一条记录，这个记录里可以说明一下登录的用户是谁，然后把这条记录的 ID 号发送给客户端，客户端收到以后把这个 ID 号存储在 Cookie 里，下次这个用户再向服务端发送请求的时候，可以带着这个 Cookie ，这样服务端会验证一个这个 Cookie 里的信息，看看能不能在服务端这里找到对应的记录，如果可以，说明用户已经通过了身份验证，就把用户请求的数据返回给客户端。\n\n上面说的就是 Cookie-Session 身份验证的过程。这解决了 HTTP 无状态的问题，但是也带来了一些其他问题，比如：XSS（Cross Site Scripting）跨站脚本攻击和 CSRF（Cross-site request forgery）跨站请求伪造。\n\n##### XSS（Cross Site Scripting）跨站脚本攻击\n\nXSS 攻击是指网页中漏洞，通过巧妙的方法被注入恶意代码，当用户加载页面的时候自动执行恶意代码的程序。攻击成功后，攻击者可能得到更高的权限（如执行一些操作）、私密网页内容、会话和 cookie等各种内容。\n\n假如页面中出现了 XSS 漏洞，由于 Cookie 是可以被 JS 获取的，攻击者可以获取到用户的 cookie 从而能够操作用户的账户等。在设置 cookie 的时候，设置httpOnly 选项使得 JS 不能读取到 cookie，那么 XSS 注入的问题也基本不用担心了。这时候还存在有另外一种攻击手段。\n\n##### CSRF（Cross-site request forgery）跨站请求伪造\n\n浏览器在访问同一个网站时会自动携带上 cookie。如果此时已经通过了验证，攻击者可以在自己的页面内访问目标网站并执行一些操作。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去执行。可以说 CSRF 是利用网站对用户网页浏览器的信任进行攻击的。\n\nCSRF 有两种防御措施：一个是检查Referer字段，另一个是添加校验token。Referer字段简单有效，但是也有些缺陷，一是无法保证所有浏览器都有具体实现，甚至有些用户由于隐私问题手动关闭Referer字段，另外也无法保证Referer字段是否有其他漏洞。添加校验token是比较有效的防御 CSRF 攻击的措施。由于浏览器在访问同一个网站时会自动携带上 cookie，所以只要身份验证信息不保存在 cookie 中，并且攻击者无法伪造验证信息，那么攻击者就无法再执行 CSRF 攻击。\n\n#### Token 身份验证\n\n先看认证的\n流程图：\n\n![基于token的身份验证流程](token1.png)\n\n\ntoken 身份验证的过程：\n\n1. 用户发送用户名密码进行登录；\n2. 登录之后生成一个 token，随响应返回。这里有两种方式返回 token，一种是放入 cookie 中，前端从 cookie 中取出加到请求头中，但是一旦设置httponly，前端就无法获取到后台设置的 cookie 了，这种方法不适合。所以 token 就改为随响应返回。\n3. 前端将其存在 localstorage 或者中 cookie。一是保存在 localstorage 有弊端，有些上古浏览器，比如ie 567，并不支持 localstorage，需要一个 polyfill 来兼容所有浏览器。二是保存在cookie中，这里只是将cookie作为一种储存来使用，不会受到后端设置 httponly 的影响，另外这里token保存在cookie中，由于需要手动放入请求头，不会影响验证。\n4. 发送请求时，由 JS 操作取出保存的 token，并在请求头上加上 Authorization：token，发送请求；\n5. 后台拦截请求（主要是post，put，detele等请求）进行 token 校验，通过执行逻辑返回数据，不通过重定向到登录界面或者返回认证失败；\n\n\n\n\n","tags":["CSRF"],"categories":["网络安全"]},{"title":"HTML条件注释","url":"/2017/12/23/webfront/HTML条件注释/","content":"简单介绍下 HTML 条件注释\n<!--more-->\n\n```html\n<!--[if !IE]><!--> 除IE外都可识别 <!--<![endif]-->\n<!--[if IE]> 所有的IE可识别 <![endif]-->\n<!--[if IE 6]> 仅IE6可识别 <![endif]-->\n<!--[if lt IE 6]> IE6以及IE6以下版本可识别 <![endif]-->\n<!--[if gte IE 6]> IE6以及IE6以上版本可识别 <![endif]-->\n<!--[if IE 7]> 仅IE7可识别 <![endif]-->\n<!--[if lt IE 7]> IE7以及IE7以下版本可识别 <![endif]-->\n<!--[if gte IE 7]> IE7以及IE7以上版本可识别 <![endif]-->\n<!--[if IE 8]> 仅IE8可识别 <![endif]-->\n<!--[if IE 9]> 仅IE9可识别 <![endif]-->\n```\n\n使用 HTML 条件注释可以使得某些标签或者脚本只在指定的版本下加载。\n\n其中：\n\n* lte：就是Less than or equal to的简写，也就是小于或等于的意思。\n* lt ：就是Less than的简写，也就是小于的意思。\n* gte：就是Greater than or equal to的简写，也就是大于或等于的意思。\n* gt ：就是Greater than的简写，也就是大于的意思。","tags":["条件注释"],"categories":["web前端"]},{"title":"如何兼容到IE8","url":"/2017/12/21/webfront/如何做IE低版本兼容/","content":"\n在开发前端项目中，最痛苦的就是进行IE低版本浏览器的兼容和适配。现在的项目没有特殊要求一般兼容到 IE8 就可以了。那我们在进行开发的时候，应该怎么去支持 IE 浏览器呢？由于 ES6 的特性各个浏览器支持的参差不齐，我们经常会使用 Babel 转 ES5 后\b，\b运行在浏览器上。今天要讨论的是项目兼容到 IE8 的问题。\n<!--more-->\n\n#### 选择库和框架\n\n在前端开发的时候，选择库和框架的时候，一定要注意的就是文档中的浏览器支持情况。假如框架或者库只支持到 IE11，那么基于该框架的项目也只能是支持 IE11 或以上的浏览器。项目的 IE 兼容性是取项目中所有库的支持IE版本下限最高的那个。所以要使得项目兼容到 IE8，我们在挑选框架和库的时候，\b所有都要选择最低支持到 IE8 或以下。\n\n#### 设置文档兼容模式\n\n```js\n<meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n```\nEdge 模式告诉 IE 以最高级模式渲染文档，也就是任何IE版本都以当前版本所支持的最高级标准模式渲染，避免版本升级造成的影响。简单的说，就是什么版本 IE 就用什么版本的标准模式渲染。\n\n```js\n<meta http-equiv=\"X-UA-Compatible\" content=\"chrome=1\">\n```\n\n上面这个meta标签是\b强制 IE 使用 Chrome Frame 渲染。\n\n最佳的兼容模式方案，结合考虑以上两种：\n\n```js\n<meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n```\n\n#### 支持 ES5 方法\n\n\b在`<head>`标签中加上下面代码：\n\n```html\n    <!--[if lt IE 9]>\n    <script type=\"text/javascript\" src=\"js/es5-shim.min.js\"></script>\n    <script type=\"text/javascript\" src=\"js/es5-sham.min.js\"></script>\n    <script type=\"text/javascript\" src=\"js/respond.min.js\"></script>\n    <![endif]-->\n```\n\nHTML条件注释见 {% post_link webfront/HTML条件注释 HTML条件注释 %} 。\n\n`es5-shim.js` 完美模拟了所有 ES5 中可以被完美模拟的方法。文档见GitHub [es5-shim](https://github.com/es-shims/es5-shim)。\n\n`es5-sham.js` 尽量的模拟一些无法被完美模拟的方法，并保证代码不会崩溃，但不保证方法的功能全部正常运行。\n\n\b这两个可以让一些只支持 ES3 的老旧浏览器运行 ES5 时不会出现大的问题。\n\n#### 支持媒体查询\n\n ```html\n    <!--[if lt IE 9]>\n    <script src=\"html5shiv.min.js\"></script>\n    <![endif]-->\n ```\n`Respond.js`让不支持`css3 Media Query`的浏览器包括 IE6-IE8 等其他浏览器支持查询。文档见GitHub [Respond](https://github.com/scottjehl/Respond)。\n\n#### 支持 HTML5 标签\n\n 如果开发中使用到了 HTML5 标签，还需要加入以下代码：\n\n ```html\n    <!--[if lt IE 9]>\n    <script src=\"html5shiv.min.js\"></script>\n    <![endif]-->\n ```\n `html5shiv`使得传统浏览器支持部分 HTML5 元素并提供相应的基本样式。传统浏览器，即主流浏览器的低版本，包括IE6-9、Safari4.x和Firefox 3.x等。文档参见 GitHub [html5shiv](https://github.com/aFarkas/html5shiv)。\n\n 目前想到的就这么多，欢迎评论补充。\n","tags":["HTML条件注释"],"categories":["web前端"]},{"title":"Meta 标签中的 SEO 优化","url":"/2017/12/17/webfront/Meta标签中的SEO优化/","content":"\n本文主要介绍`Meta`标签中和`SEO`优化有关的标签，`description`，`robots`，`keywords`和`title`，以及优化建议。\n<!--more-->\n\n#### Meta Description\n\n`Meta description`标签可能是最有用的标签之一。顾名思义，它会给搜索引擎提供关于这个网页的简短的描述。代码如下:\n\n```html\n<meta name=\"description\" content=\"页面简介\"/>\n```\n\n有这个标签之后，搜索引擎会在搜索结果页链接的下方显示出这个网页的简短的描述。推荐的`description`长度为160 个字符。\n\n但是如果你没有使用`description`标签，搜索引擎仍会在搜索结果页链接的下方显示出自己创键的一小段文字或者干脆为空。没有简介或者不精确的简介，会让搜索结果略显单薄，也就意味着你将可能失去用户点击网页的机会。\n\n#### Meta Robots\n\n`Meta robots`标签管理着搜索引擎是否可以进入网页，你可以用它来允许或不允许搜索引擎来获取你的网页、进入你网页中的子链接或对你的网页存档。例如：\n\n```html\n<meta name=\"robots\" content=\"noindex,nofollow\"/>\n```\n\n这个 `meta` 标签告诉搜索引擎不要获取网页，并且阻止其进入链接。如果你不小心使用了两个矛盾的术语 (例如noindex 和index)，谷歌会选择最具限制性的选项。\n\n为什么这个标签会对搜索引擎优化(SEO)起作用呢?首先，它可以防止对拷贝内容的冗余抓取，例如页面的打印版页面。它也可能会对那些内容不完整的页面或者而存在私密信息的网页起作用。\n\n#### Meta Keywords\n\n在meta keywords标签里面，你可以存储几个关于网页内容的关键字。代码如下：\n\n```html\n<meta name=\"keywords\" content=\"关键字,keyword\"/>\n```\n\n不过现在主流的搜索引擎很少使用meta keywords来判断网页的内容了。设置这个标签的可能价值不太高。\n\n#### Title\n\n专业的讲，`title`标签不是`meta`标签，但他们都放在相同位置，它对搜索引擎优化很重要。\n\n在所有的`HTML`文档中，`title`标签都是不可缺少的。它定义了整个文档的标题，如下所示：\n\n```html\n<title>Title of the page</title>\n```\n\n标题通常会显示在两个不同的地方：浏览器的头部标签和搜索结果页。这就意味着`title`标签在点击率(CTR)和排名上有很重要的影响。\n\n一个好的标题应该包含关键字，而且最好放在标题的开头部分。谷歌会限制标题为70个字符，所以需要书写一个合适的标题。\n\n#### 总结\n\n经过上面的介绍，一般的来说，Meta标签中的SEO优化加上`keywords`标签和`description`标签就可以了。\n\n```html\n<meta name=\"description\" content=\"页面简介\"/>\n<meta name=\"keywords\" content=\"关键字,keyword\"/>\n```\n","tags":["seo"],"categories":["web前端"]},{"title":"PhantomJs 踩坑","url":"/2017/12/15/webfront/PhantomJs踩坑/","content":"`PhantomJs`遇到的问题\n<!--more-->\n##### 问题\n\n* phantomjs 环境下不能给 window.localStorage 赋值，会引起 phantomjs 占用内存、CPU 等资源占用飙涨。","tags":["踩坑"],"categories":["web前端"]},{"title":"Meta 标签控制 IE 渲染模式","url":"/2017/12/12/webfront/meta标签控制IE渲染模式/","content":"\n`meta`标签控制`IE`渲染标准模式和兼容模式\n<!--more-->\n\n“X-UA-Compatible”的值有三种方式：\n1. Edge;\n2. Emulate+IE版本号;\n3. 单纯版本号。\n\n\n```html\n<meta http-equiv=\"x-ua-compatible\" content=\"IE=Edge\" >  \n```\nEdge：始终以最新的文档模式来渲染页面。忽略文档类型声明。对于IE8，始终以IE8标准模式渲染页面。IE9亦如此。\n\n```html\n<meta http-equiv=\"x-ua-compatible\" content=\"IE=EmulateIE9\" >  \n```\n\n* EmulateIE9：如果声明了文档类型，则以IE9标准模式渲染页面，否则将文档模式设置为IE5。\n* EmulateIE8：如果声明了文档类型，则以IE8标准模式渲染页面，否则将文档模式设置为IE5。 \n* EmulateIE7：如果声明了文档类型，则以IE7标准模式渲染页面，否则将文档模式设置为IE5。\n \n```html\n<meta http-equiv=\"x-ua-compatible\" content=\"IE=9\" >  \n```\n\n* 9：强制以IE9标准模式渲染页面，忽略文档类型声明。\n* 8：强制以IE8标准模式渲染页面，忽略文档类型声明。\n* 7：强制以IE7标准模式渲染页面，忽略文档类型声明。\n* 5：强制以IE5标准模式渲染页面，忽略文档类型声明。\n\n\n\n","tags":["兼容"],"categories":["web前端"]},{"title":"打包electron应用","url":"/2016/05/20/quickstart/electron/打包electron应用/","content":"\n运行第一个程序之后，我希望自己写的程序能够给别人运行，这就涉及到应用的打包。\n<!--more-->\n在项目的目录下，打开终端运行命令安装electron打包工具。\n```bash\nnpm install electron-packager --save-dev\n```\n## 打包应用\n\n安装完毕之后，在`packsge.json`中添加构建脚本。\n```json\n\"scripts\": {\n    \"start\": \"electron .\",\n    \"build\": \"electron-packager . MyApp --platform=darwin --arch=x64 --ignore=node_modules/electron-*\"\n  }\n```\nelectron-packager的格式：\n```bash\nelectron-packager 项目目录 app名称 --platform=平台 --arch=架构 --ignore=要忽略的目录或文件\n# 详细的参数和使用方法可以是使用命令 --help的形式查看帮助\n```\n保存之后，在终端运行\n```bash\nnpm run build\n```\n*注意*：这个运行会下载没有的平台的构建包，网速慢的话需要不少时间。\n\n完成之后就会在目录下生成一个appname-platform-arch名字的文件夹，打包好的应用就在文件夹中。\n\n![](1.png)\n\n## 压缩源码\n\n生成应用的时，有时候不希望直接暴漏源码。使用源码压缩就可以将源码打包成一个asar的包。\n同样需要添加脚本，现在的脚本是这样的：\n```json\n\"scripts\": {\n    \"start\": \"electron .\",\n    \"package\": \"asar pack MyApp-darwin-x64/MyApp.app/Contents/Resources/app MyApp-darwin-x64/MyApp.app/Contents/Resources/app.asar\",\n    \"build\": \"electron-packager . MyApp --platform=darwin --arch=x64 --ignore=node_modules/electron-*\"\n  }\n```\n在终端运行：\n```bash\nnpm install package\n```\n现在打开app包就可以看见同名的asar的，然后删除原来的源码包就可以了。\n\n![](2.png)","tags":["Electron"],"categories":["入门"]},{"title":"新建Electron应用","url":"/2016/05/20/quickstart/electron/Try-Electron/","content":"\nElectron 框架的前身是 Atom Shell，可以让你写使用 JavaScript，HTML 和 CSS 构建跨平台的桌面应用程序。\n<!--more-->\n它是基于io.js 和 Chromium 开源项目，并用于在 Atom 编辑器中。Electron 是开源的，由 GitHub 维护，有一个活跃的社区。最重要的是，Electron 应用服务构建和运行在 Mac，Windows 和 Linux。\n\n## 建立npm工程\n\n新建工程文件夹，使用npm初始化一个npm项目\n\n```bash\nnpm init\n```\n\n接下来npm会引导你进行一个配置向导，配置完成之后会生成一个``package.json``的配置文件。配置文件大概是这样的：\n\n```json\n{\n  \"name\": \"electron-app\",\n  \"version\": \"1.0.0\",\n  \"description\": \"electron-app\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"author\": \"jinsihou\",\n  \"license\": \"MIT\"\n}\n```\n\n## 安装Electron\n运行以下命令安装electron。\n```bash\nnpm i electron-prebuilt --save-dev    #保存在依赖中以便下次使用\n```\n安装完成之后，在工程目录下建立一个`index.js`，这个名字需要和`package.json`配置的main项保持一致。填入以下内容。\n\n```javascript\nconst {app, BrowserWindow} = require('electron')\n\napp.on('ready', function(){\n  var mainWindow = new BrowserWindow({\n    width: 800,\n    height: 600\n  });\n})\n```\n\n保存之后，现在我们来运行一下，编辑`package.json`,在scripts下添加一项。\n\n```json\n\"scripts\": {\n  \"start\": \"electron .\"\n}\n```\n\n然后运行命令，启动应用。\n\n```bash\nnpm start\n```\n\n这就是一个最简单的electron应用，它只有一个800*600的空窗口。\n\n## Hello electron\n编辑`index.js`，添加一个html作为内容。\n\n```javascript\nconst {app, BrowserWindow} = require('electron')\napp.on('ready', function(){\n  var mainWindow = new BrowserWindow({\n  \twidth: 800,\n  \theight: 600\n  });\n  mainWindow.loadURL('file://' + __dirname + '/index.html');\n})\n```\n\n新建一个`index.html`\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n  <title></title>\n</head>\n<body>\n  Hello electron\n</body>\n</html>\n```\n\n运行如图：\n![](1.png)\n\n\n","tags":["Electron"],"categories":["入门"]},{"title":"构建Hexo静态网站","url":"/2016/05/19/quickstart/部署和简单使用hexo/","content":"\n这个`Hexo`部署有一段时间了，但是时间久了之后，已经忘记了如何写文章及部署到`github.io`，所以记录在这，以供回顾。\n<!--more-->\n#### 安装git\n\n下载并安装`git`或者是`github`，了解点Git的基础命令就可以完成本任务。\n\n#### 安装Node.js\n\n到官网下载并安装`Node.js`，最好选择稳定版。\n\n#### npm\n\n`npm`是`nodejs`的模块管理器，`npm`在`nodejs`中自带，介绍几个常用命令，#之后为注释。\n``` bash\nnpm --help          #npm帮助，查看其他命令的使用方法\nnpm i module_name   #安装node模块完整的命令是npm install\nnpm i               #单独使用的时候，可以根据文件夹下的package.json配置文件自动安装依赖\nnpm init            #初始化一个init工程，会启动一个向导一样的配置，成功之后会生成一个package.json\n```\n\n#### 安装Hexo\n\n安装全局Hexo：\n```bash\nnpm install hexo-cli -g\nnpm install hexo -g\n```\n新建一个工程文件夹，在该文件夹下运行命令，Hexo会自动在该文件夹下下载搭建网站所需的所有文件。\n```bash\nhexo init\n```\n安装依赖\n```bash\nnpm install\n```\n现在就已经安装好了基本内容了，现在介绍几个Hexo常用命令\n\n```bash\nhexo g #完整命令为hexo generate,用于生成静态文件\nhexo s #完整命令为hexo server,用于启动服务器，主要用来本地预览\nhexo d #完整命令为hexo deploy,用于将本地文件发布到github上\nhexo n #完整命令为hexo new,用于新建一篇文章，包括自动建立资源文件夹\n```\n\n本地运行一下安装好的hexo\n\n```bash\nhexo g\nhexo s\n```\n\n然后用浏览器访问`http://localhost:4000/`此时，你应该看到了一个漂亮的博客了，当然这个博客只是在本地的，别人是看不到的,我们需要把他发布到`github.io`上。\n\n#### 部署本地文件到`github`\n\n编辑hexo工程下的`_config.yml`文件,在`_config.yml`最下方，添加如下配置：\n\n```bash\ndeploy:\n  type: git\n  repository: https://github.com/jinsihou19/jinsihou19.github.io.git\n  branch: master\n  message: new\n```\n保存之后运行以下命令部署到`github`上，第一次运行会要求输入密码。\n\n```bash\nhexo g\nhexo d\n```\n\n#### `hexo`的配置文件\n\n`hexo`里面有两个常用到的配置文件，分别是整个博客的配置文件`hexo/_config.yml`和主题的配置文件`hexo/themes/hueman/_config.yml`。接下来介绍整个博客的配置文件。\n\n```bash\n# Hexo Configuration\n## Docs: http://hexo.io/docs/configuration.html\n## Source: https://github.com/hexojs/hexo/\n\n# Site\t这下面的几项配置都很简单，你看我的博客就知道分别是什么意思\ntitle: 金丝猴的博客 #博客名\nsubtitle:\ndescription:\nauthor: 金丝猴\nlanguage: zh-CN\ntimezone:     #时区，此处不填写，hexo会以你目前电脑的时区为默认值\n\n# URL\t暂不配置，使用默认值\n## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'\nurl: http://jinsihou19.github.io  #域名\nroot: /\npermalink: :year/:month/:day/:title/\npermalink_defaults:\n\n# Directory\t\t暂不配置，使用默认值\nsource_dir: source\npublic_dir: public\ntag_dir: tags\narchive_dir: archives\ncategory_dir: categories\ncode_dir: downloads/code\ni18n_dir: :lang\nskip_render:\n\n# Writing\t文章布局等，使用默认值\nnew_post_name: :title.md # File name of new posts\ndefault_layout: post\ntitlecase: false # Transform title into titlecase\nexternal_link: true # Open external links in new tab\nfilename_case: 0\nrender_drafts: false\npost_asset_folder: false\nrelative_link: false\nfuture: true\nhighlight:\n  enable: true\n  line_number: true\n  tab_replace:\n\n# Category & Tag\t暂不配置，使用默认值\ndefault_category: uncategorized\ncategory_map:\ntag_map:\n\n# Date / Time format\t时间格式，使用默认值\n## Hexo uses Moment.js to parse and display date\n## You can customize the date format as defined in\n## http://momentjs.com/docs/#/displaying/format/\ndate_format: YYYY-MM-DD\ntime_format: HH:mm:ss\n\n# Pagination\n## Set per_page to 0 to disable pagination\nper_page: 10\t#每页显示的文章数，0表示不分页\npagination_dir: page\n\n# Extensions\t插件配置，暂时不配置\n## Plugins: http://hexo.io/plugins/\n## Themes: http://hexo.io/themes/\nplugins:\n- hexo-generator-feed\ntheme: hueman\t#使用的主题，即：myblog\\themes文件夹下的主题文件夹名\n\nfeed:\t#之后配置rss会用，使用如下配置即可\n  type: atom\n  path: atom.xml\n  limit: 20  \n\n# Deployment\t用于部署到github，之前已经配置过\n## Docs: http://hexo.io/docs/deployment.html\n\ndeploy:\n  type: git\n  repository: https://github.com/jinsihou19/jinsihou19.github.io.git\n  branch: master\n```\n\n#### 发表一篇文章\n\n想要新建文章的时候，在项目文件夹下运行命令：\n\n```bash\nhexo new \"my new post\"\n```\n使用`Markdown`进行编辑，这是用命令创建出来的md文件模板。\n\n```bash\ntitle: my new post #可以改成中文的，如\"新文章”\ndate: 2015-04-08 22:56:29 #发表日期，一般不改动\ncategories: blog #文章文类\ntags: [博客，文章] #文章标签，多于一项时用这种格式，只有一项时使用tags: blog\n---\n#这里是正文，用markdown写，你可以选择写一段显示在首页的简介后，加上\n<!--more-->\n#在<!--more-->之前的内容会显示在首页，之后的内容会被隐藏，当游客点击Read more才能看到。\n```\n\n写完文章后，部署的步骤：\n1. `hexo g`生成静态文件。\n2. `hexo s`在本地预览效果。\n3. `hexo d`同步到github，然后使用`http://jinsihou19.github.io`进行访问。\n\n##### 小技巧\n\n* 一些网站的静态资源例如`favicon.ico`、`images`等或者`github`的`CNAME`文件（用于指定自定义域名），每次设置之后都会消失。将需要直接上传至`github`的内容放在`source`文件夹下即可。\n\n","tags":["Nodejs"],"categories":["入门"]},{"title":"事件代理和json对象的操作","url":"/2016/03/28/webfront/事件代理和json对象的操作/","content":"\n任务十六 事件代理和json对象的操作\n<!--more-->\n### json对象的操作\n\n```javascript\naqiData = {\n\t\"北京\": 90,\n\t\"上海\": 40\n};\n```\n\n1. 添加\n\n```javascript\naqiData[city] = value;\n```\n2. 遍历\n\n```javascript\n\tfor (let data in aqiData) {\n\t\tconsole.info(consldata:aqiData[data]);\n\t}\n```\n3. 删除\n\n```javascript\ndelete aqiData[data];\n```\n\n### 事件代理机制\n\n*事件代理机制*\n>当我们需要对很多元素添加事件的时候，可以通过将事件添加到它们的父节点而将事件委托给父节点来触发处理函数。这主要得益于浏览器的事件冒泡机制。\n\n*浏览器的事件冒泡机制*\n>DOM2.0模型将事件处理流程分为三个阶段：一、事件捕获阶段，二、事件目标阶段，三、事件起泡阶段。如图：\n\n>事件捕获：当某个元素触发某个事件（如onclick），顶层对象document就会发出一个事件流，随着DOM树的节点向目标元素节点流去，直到到达事件真正发生的目标元素。在这个过程中，事件相应的监听函数是不会被触发的。\n\n>事件目标：当到达目标元素之后，执行目标元素该事件相应的处理函数。如果没有绑定监听函数，那就不执行。\n\n>事件起泡：从目标元素开始，往顶层元素传播。途中如果有节点绑定了相应的事件处理函数，这些函数都会被一次触发。如果想阻止事件起泡，可以使用e.stopPropagation()（Firefox）或者e.cancelBubble=true（IE）来组织事件的冒泡传播。\n\n![](http://images.cnitblog.com/blog/477973/201302/18141423-8bd09a9c1e184df9a13b6e26b88348f3.jpg)\n\n*实例*\n\n```html\n<table id=\"aqi-table\" border=\"1px\">\n\t<tr>\n\t\t  <td>城市</td><td>空气质量</td><td>操作</td>\n\t</tr>\n\t<tr>\n\t\t  <td>北京</td><td>90</td><td><button>删除</button></td>\n\t</tr>\n\t<tr>\n\t\t  <td>北京</td><td>90</td><td><button>删除</button></td>\n\t</tr>\n</table>\n```\n当事件被抛到更上层的父节点的时候，我们通过检查事件的目标对象（target）来判断并获取事件源对象。我这里没有判断是否是这个对象。\n\n```javascript\n//由上层（泛指）来捕获这个事件，然后回溯到事件触发者来进行处理\ntable.addEventListener('click', function (e) {\n    if (e.target) {//这里的taget就是button\n\t    let context = e.target.parentNode.parentNode.firstChild.innerText;\n\t    delete aqiData[context];\n\t}\n});\n\n```\n","tags":["javascript"],"categories":["web前端"]},{"title":"使用 bower 搭建 bootstrap 工程","url":"/2016/03/28/webfront/使用bower搭建bootstrap工程/","content":"\n使用`bower`搭建`bootstrap`工程\n<!--more-->\n\n**搭建工程**\n\n1. 建立项目文件夹如下的目录结构(都是空文件夹)\n\n    ![](/image/1.png)\n\n2. 安装bower包管理器,推荐阅读下面的安装教程:\n\n    >https://segmentfault.com/a/1190000000349555\n\n3. 安装好bower之后,切换到项目文件夹下,新建一个.bowerrc文件,在其中加入代码\n\n\n```json\n\t{\n\t\t\"directory\" : \"assets/lib\"\n\t}\n```\n\n并保存;\n\n4. 打开命令行切换到项目文件下\n\n```cmd\n\tbower install bootstrap\n```\n\n到项目下就发现在bower_components目录下安装好了bootstrap和jquery,因为bower会自动管理依赖,所以自动安装了jquery;\n\n5. 依旧在项目文件夹下,在命令行运行:\n\n```cmd\n   bower init\n```\n\n这里有个参考\n\n![](/image/2.png)\n\n然后按照提示选择选项,就可以了,完成这步,就完成项目的创建了,使用WebStorm打开就可以进行开发.\n\n\n**clone工程的运行**\n\n1. (clone别人的工程的时候使用)当clone一份有bower.json的项目时,切换到项目文件夹下,在命令行运行:\n\n```cmd\n\tbower install\n```\n\n这时候,所有的依赖库都会安装完毕.\n\n2. 使用WebStorm打开工程就可以进行开发了.\n\n\n\n**关于.gitignore要写什么**\n**这里注意要将依赖库的文件夹和工程配置都加到忽略名单中,本工程的.gitignore参考内容如下:**\n\n```\n\t.idea\n\tnode_modules\n\tassets/lib\n```\n","tags":["搭建工程"],"categories":["web前端"]},{"title":"Hello World","url":"/2016/03/27/quickstart/hello-world/","content":"Hello World\n<!--more-->\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n ","categories":["入门"]}]